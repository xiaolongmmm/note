

[https://blog.csdn.net/u011535541/article/details/83379151ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163521376716780261994904%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=163521376716780261994904&biz_id](https://blog.csdn.net/u011535541/article/details/83379151?ops_request_misc=%7B%22request%5Fid%22%3A%22163521376716780261994904%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=163521376716780261994904&biz_id)，本人在csdn进行学习并进行实操仅为笔记记录，上述链接为原文。

#### 一：Git是什么？

Git是目前世界上最先进的分布式版本控制系统。

#### 二：Git工作原理/流程

![image-20220810150755595](D:\笔记\Git的使用\image-20220810150755595.png)


命令如下：
1. clone（克隆）: 从远程仓库中克隆代码到本地仓库
2. checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订
3. add（添加）: 在提交前先将代码提交到暂存区
4. commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本
5. fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。
6. pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge
7. push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库



#### 三：SVN与Git的最主要的区别？

[SVN](https://so.csdn.net/so/search?q=SVN&spm=1001.2101.3001.7020)是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。

Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

#### 四：Git操作

##### 1.创建版本库

什么是版本库？版本库又名仓库，英文名repository，可以理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。

①在本地创建一个目录

②通过命令 git init 把这个目录变成git可以管理的仓库，如下：

![image-20220810151034038](D:\笔记\Git的使用\image-20220810151034038.png)

这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的。

③把文件添加到版本库中

首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但具体改了什么，版本控制也不知道。

​		（1）使用命令 git add readme.txt添加到暂存区里面去。

![image-20220810152015540](D:\笔记\Git的使用\image-20220810152015540.png)

​		（2）用命令 git commit告诉Git，把文件提交到仓库。

![image-20220810152054108](D:\笔记\Git的使用\image-20220810152054108.png)

​		（3）提交了一个readme.txt文件，可以通过命令git status来查看是否还有文件未提交，如下说明没有文件未提交。

![image-20220810152151019](D:\笔记\Git的使用\image-20220810152151019.png)

​		（4）继续来改下readme.txt内容，在下面添加一行2222222222内容，继续使用git status来查看下结果。

![image-20220810152328719](D:\笔记\Git的使用\image-20220810152328719.png)

​		（5）上面的命令说明 readme.txt文件已被修改，但是未被提交的修改。可以用git diff readme.txt 来看具体修改了什么内容。

![image-20220810153405558](D:\笔记\Git的使用\image-20220810153405558.png)

​		（6）知道了对readme.txt文件做了什么修改后，按照前两部执行即可。

##### 2.版本回退

①继续对readme.txt文件进行修改，再增加一行内容为33333333333333.继续执行命令

②已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，可以使用命令 git log 

![image-20220810154257557](D:\笔记\Git的使用\image-20220810154257557.png)

commit为每次提交的版本号

③git log命令显示从最近到最远的显示日志，可以使用命令 git log –pretty=oneline简化信息

![image-20220810154507051](D:\笔记\Git的使用\image-20220810154507051.png)

④使用版本回退操作，把当前的版本回退到上一个版本，可以使用如下2种命令，第一种是：git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。如果要回退到前100个版本的话，可以使用下面的简便命令操作：git reset --hard HEAD~100。未回退之前的readme.txt内容如下

![image-20220810154835860](D:\笔记\Git的使用\image-20220810154835860.png)

如果想回退到上一个版本的命令如下操作：

![image-20220810154935947](D:\笔记\Git的使用\image-20220810154935947.png)

再来查看下 readme.txt内容如下：通过命令cat readme.txt查看

![image-20220810155013777](D:\笔记\Git的使用\image-20220810155013777.png)

内容已经回退到上一个版本了，可以继续使用git log 来查看下历史记录信息，如下

![image-20220810155050943](D:\笔记\Git的使用\image-20220810155050943.png)

增加33333 内容我们没有看到了，如果想回退到最新的版本，我们可以通过版本号回退，使用命令方法如下：

git reset --hard 版本号，可以通过如下命令即可获取到版本号：git reflog 

![image-20220810155317587](D:\笔记\Git的使用\image-20220810155317587.png)

通过上面的显示可以知道，增加内容33333的版本号是 b974d61.我们现在可以命令git reset --hard b974d61来恢复了

![image-20220810155550669](D:\笔记\Git的使用\image-20220810155550669.png)

##### 3.理解工作区与暂存区的区别？

①工作区：就是在电脑上看到的目录，比如目录下testgit(原先创建的文件，上述所有操作都在testgit文件夹中进行)里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。

②版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。

前面说过使用Git提交文件到版本库有两步：

第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。

第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。

演示：

![image-20220811170211195](D:\笔记\Git的使用\image-20220811170211195.png)

使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态

![image-20220811170640740](D:\笔记\Git的使用\image-20220811170640740.png)

接着可以使用git commit一次性提交到分支上

![image-20220811170929371](D:\笔记\Git的使用\image-20220811170929371.png)

##### 4.Git撤销修改和删除文件操作

①撤销修改：

在readme.txt文件里面增加一行 内容为555555555555，先通过命令查看如下：

![image-20220811171628098](D:\笔记\Git的使用\image-20220811171628098.png)

在未提交之前，我发现添加5555555555555内容有误，所以得马上恢复以前的版本，现在可以有如下几种方法可以做修改：

第一：如果知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。

第二：可以按以前的方法直接恢复到上一个版本。使用 git reset --hard HEAD^

但是现在不想使用上面的2种方法，想直接想使用撤销命令该如何操作呢？首先在做撤销之前，可以先用 git status 查看下当前的状态。如下所示：

![image-20220811172117353](D:\笔记\Git的使用\image-20220811172117353.png)

可以发现，Git会告诉你，git checkout -- file 可以丢弃工作区的修改，如下命令：git checkout -- readme.txt,如下所示：

![image-20220811172452911](D:\笔记\Git的使用\image-20220811172452911.png)

1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。

2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。
对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：

![image-20220811173220947](D:\笔记\Git的使用\image-20220811173220947.png)

注意：命令git checkout -- readme.txt 中的 -- 很重要，如果没有 -- 的话，那么命令变成创建分支了。

②删除文件

在版本库testgit目录添加一个文件b.txt,然后提交。如下：

![image-20220812170341216](D:\笔记\Git的使用\image-20220812170341216.png)

一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的

​                                                            commit操作：

![image-20220812170923566](D:\笔记\Git的使用\image-20220812170923566.png)

![image-20220812171017098](D:\笔记\Git的使用\image-20220812171017098.png)

只要没有commit之前，如果想在版本库中恢复此文件如何操作呢？

可以使用如下命令 git checkout -- b.txt，如下所示：

![image-20220812171746598](D:\笔记\Git的使用\image-20220812171746598.png)

再来看看testgit目录，添加回了b.txt文件。如下所示：

![image-20220812171804269](D:\笔记\Git的使用\image-20220812171804269.png)

##### 5.远程仓库

在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：

第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：

ssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：

![image-20220812173014317](D:\笔记\Git的使用\image-20220812173014317.png)



![image-20220812173103701](D:\笔记\Git的使用\image-20220812173103701.png)

id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。

![image-20220815090346552](D:\笔记\Git的使用\image-20220815090346552.png)

点击 Add Key，就应该可以看到已经添加的key

![image-20220815090552935](D:\笔记\Git的使用\image-20220815090552935.png)

如何添加远程库？
现在的情景是：已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。

首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：

![image-20220815093046962](D:\笔记\Git的使用\image-20220815093046962.png)

在Repository name填入MyFirstGit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：

![image-20220815093532230](D:\笔记\Git的使用\image-20220815093532230.png)

目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。

现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：

git remote add origin https://github.com/xiaolongmmm/MyFirstGit.git

所有的如下：

![image-20220815094034861](D:\笔记\Git的使用\image-20220815094034861.png)

把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。

由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：

![image-20220815094331504](D:\笔记\Git的使用\image-20220815094331504.png)

从现在起，只要本地作了提交，就可以通过如下命令：

git push origin master

把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。

1. 如何从远程库克隆？

   上面我们了解了先有本地库，后有远程库时候，如何关联远程库。

   现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？

   首先，登录github，创建一个新的仓库，名字叫testgit2.如下：

   ![](D:\笔记\Git的使用\image-20220815094547745.png

   

![image-20220815094746323](D:\笔记\Git的使用\image-20220815094746323.png)

如下，我们看到：

![image-20220815094853959](D:\笔记\Git的使用\image-20220815094853959.png)

现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：

![image-20220815095406218](D:\笔记\Git的使用\image-20220815095406218.png)

接着在本地目录下生成testgit2目录了，如下所示：

![image-20220815095439588](D:\笔记\Git的使用\image-20220815095439588.png)

##### 6.创建与合并分支

在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。

首先，我们来创建dev分支，然后切换到dev分支上。如下操作：

![image-20220815100006601](D:\笔记\Git的使用\image-20220815100006601.png)

git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令

git branch dev

git checkout dev

git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777

首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：

![image-20220815100322648](D:\笔记\Git的使用\image-20220815100322648.png)

现在dev分支工作已完成，现在切换到主分支master上，继续查看readme.txt内容如下：

![image-20220815100409089](D:\笔记\Git的使用\image-20220815100409089.png)

现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：

![image-20220815100537886](D:\笔记\Git的使用\image-20220815100537886.png)

git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。

注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

合并完成后，我们可以接着删除dev分支了，操作如下：

![image-20220815100807017](D:\笔记\Git的使用\image-20220815100807017.png)

总结创建与合并分支命令如下：

查看分支：git branch

创建分支：git branch name

切换分支：git checkout name

创建+切换分支：git checkout –b name

合并某分支到当前分支：git merge name

删除分支：git branch –d name

如何解决冲突？
下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：



![image-20220815142156002](D:\笔记\Git的使用\image-20220815142156002.png)

同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：

![image-20220815142346610](D:\笔记\Git的使用\image-20220815142346610.png)



现在我们需要在master分支上来合并fenzhi1，如下操作：

![image-20220815142617452](D:\笔记\Git的使用\image-20220815142617452.png)

![image-20220815142742157](D:\笔记\Git的使用\image-20220815142742157.png)



Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，其中<<<HEAD是指主分支修改的内容，>>>>>fenzhi1 是指fenzhi1上修改的内容，可以修改下（直接vi进去删除）如下后保存：

![image-20220816103735812](D:\笔记\note\Git的使用\image-20220816103735812.png)

如果想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下

![image-20220816104013718](D:\笔记\note\Git的使用\image-20220816104013718.png)

分支管理策略

通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：

创建一个dev分支。
修改readme.txt内容。
添加到暂存区。
切换回主分支(master)。
合并dev分支，使用命令 git merge –no-ff -m “注释” dev
查看历史记录
如下：

![image-20220816105811039](D:\笔记\note\Git的使用\image-20220816105811039.png)

分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。

##### 7.bug分支

在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。

比如在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：

![image-20220816123219200](D:\笔记\note\Git的使用\image-20220816123219200.png)

并不是不想提交，而是工作进行到一半时候，还无法提交，比如这个分支bug要2天完成，但是issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：

![image-20220816123259408](D:\笔记\note\Git的使用\image-20220816123259408.png)

所以现在可以通过创建issue-404分支来修复bug了。

首先要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：

![image-20220816123535431](D:\笔记\note\Git的使用\image-20220816123535431.png)

修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：

![image-20220816123701203](D:\笔记\note\Git的使用\image-20220816123701203.png)

现在，回到dev分支上干活了。

工作区是干净的，那么我们工作现场去哪里呢？可以使用命令 git stash list来查看下。如下：

![image-20220816123817757](D:\笔记\note\Git的使用\image-20220816123817757.png)

工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：

1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。
2.另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。
演示如下

第一种

![image-20220816123950976](D:\笔记\note\Git的使用\image-20220816123950976.png)

![image-20220816123956492](D:\笔记\note\Git的使用\image-20220816123956492.png)

![image-20220816124056482](D:\笔记\note\Git的使用\image-20220816124056482.png)

第二种

![image-20220816125024016](D:\笔记\note\Git的使用\image-20220816125024016.png)